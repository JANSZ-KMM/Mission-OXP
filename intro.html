<!-- index and head unchanged -->
<body>
  <div id="root" class="h-full"></div>

  <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      const App = () => {
          const [currentStep, setCurrentStep] = useState(0);
          const [completedTerms, setCompletedTerms] = useState([]);
          const [availableTerms, setAvailableTerms] = useState([]);
          const audioContextRef = useRef(null);
          
          const gameSequence = [
              { text: "electron transport chain", type: "essay" },
              { text: "chemiosmosis", type: "essay" },
              { text: "inner membrane of mitochondria", type: "essay" },
              { text: "NADH dehydrogenase", type: "protein" },
              { text: "succinate dehydrogenase", type: "protein" },
              { text: "coenzyme Q", type: "protein" },
              { text: "cytochrome c reductase", type: "protein" },
              { text: "cytochrome c", type: "protein" },
              { text: "cytochrome c oxidase", type: "protein" },
              { text: "ATP synthase", type: "protein" }
          ];

          const speakStep = (stepNumber) => {
              const messages = {
                  0: "Identify the stages of oxidative phosphorylation?",
                  2: "Locate where this process occurs in the cell.",
                  3: "Identify the components of the electron transport chain.",
                  9: "Identify the enzyme involved in chemiosmosis."
              };
              const text = messages[stepNumber];
              if (!text) return;
              
              window.speechSynthesis.cancel();
              const utterance = new SpeechSynthesisUtterance(text);
              utterance.rate = 1;
              window.speechSynthesis.speak(utterance);
          };

          const initAudio = async () => {
              if (!audioContextRef.current) {
                  audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
              }
              if (audioContextRef.current.state === 'suspended') {
                  await audioContextRef.current.resume();
              }
          };

          const playSound = async (type) => {
              try {
                  await initAudio();
                  const ctx = audioContextRef.current;
                  const osc = ctx.createOscillator();
                  const gain = ctx.createGain();
                  osc.connect(gain);
                  gain.connect(ctx.destination);

                  if (type === 'correct') {
                      osc.frequency.setValueAtTime(600, ctx.currentTime);
                      osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.1);
                      gain.gain.setValueAtTime(0.1, ctx.currentTime);
                  } else {
                      osc.type = 'sawtooth';
                      osc.frequency.setValueAtTime(150, ctx.currentTime);
                      gain.gain.setValueAtTime(0.1, ctx.currentTime);
                  }
                  osc.start();
                  osc.stop(ctx.currentTime + 0.2);
              } catch(e) {}
          };

          useEffect(() => {
              const shuffled = [...gameSequence].map(item => item.text).sort(() => Math.random() - 0.5);
              setAvailableTerms(shuffled);
              speakStep(0);
          }, []);

          useEffect(() => {
              if ([0, 2, 3, 9].includes(currentStep)) {
                  speakStep(currentStep);
              }
          }, [currentStep]);

          const handleDrop = async (e, targetName) => {
              e.preventDefault();
              const draggedText = e.dataTransfer.getData("text");
              const expected = gameSequence[currentStep];

              if (draggedText.toLowerCase() === expected.text.toLowerCase()) {
                  playSound('correct');
                  setCompletedTerms([...completedTerms, draggedText]);
                  setAvailableTerms(availableTerms.filter(t => t !== draggedText));
                  setCurrentStep(currentStep + 1);
              } else {
                  playSound('wrong');
              }
          };

          // … rest of your UI (unchanged) …

          return (
              <div className="flex flex-col h-full bg-slate-950 p-6 overflow-hidden">
                  <div className="flex justify-between items-center mb-6">
                      <div className="flex flex-col">
                          <h2 className="text-3xl font-black text-white uppercase tracking-tighter">I: The Mitochondrial Command Center</h2>
                          <div className="flex items-center gap-3">
                              <span className="text-sky-400 text-sm font-bold tracking-widest">Drag the labels to complete the essay and diagram.</span>
                          </div>
                      </div>
                      <div className="flex gap-4">
                          {availableTerms.length === 0 && (
                            <a href="./index.html"> 
                              <button 
                                  className="px-6 py-3 bg-emerald-600 hover:bg-emerald-500 text-white font-black rounded-xl uppercase text-xs tracking-widest transition-all shadow-xl animate-bounce border-b-4 border-emerald-800"
                              >
                                  Command center secured! Return to HQ →
                              </button>
                            </a>
                          )}
                      </div>
                  </div>

                  {/* Your diagram + drag interface unchanged */}

              </div>
          );
      };

      // Drop and Protein components unchanged
      /* … existing Drop and Protein code … */

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
  </script>
</body>
</html>
